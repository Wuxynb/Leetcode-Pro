package problems;

/**
 * 2029. 石子游戏 IX
 * Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。
 * <p>
 * Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。
 * <p>
 * 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
 * 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
 * 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入：stones = [2,1]
 * 输出：true
 * 解释：游戏进行如下：
 * - 回合 1：Alice 可以移除任意一个石子。
 * - 回合 2：Bob 移除剩下的石子。
 * 已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。
 * 示例 2：
 * <p>
 * 输入：stones = [2]
 * 输出：false
 * 解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。
 * 由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。
 * 示例 3：
 * <p>
 * 输入：stones = [5,1,2,4,3]
 * 输出：false
 * 解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：
 * - 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
 * - 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
 * - 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
 * - 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
 * - 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.
 * Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。
 * <p>
 * <p>
 * 提示：
 * <p>
 * 1 <= stones.length <= 105
 * 1 <= stones[i] <= 104
 * <p>
 * link: https://leetcode-cn.com/problems/stone-game-ix/
 */
public class Problem2029 {
    public static void main(String[] args) {
        System.out.println(stoneGameIX(new int[]{1, 2})); // true
        System.out.println(stoneGameIX(new int[]{2})); // false
        System.out.println(stoneGameIX(new int[]{5, 1, 2, 4, 3})); // false
        System.out.println(stoneGameIX(new int[]{1, 1, 7, 10, 8, 17, 10, 20, 2, 10})); // true
    }

    /**
     * 思路与算法
     *
     * 由于玩家的目标是使得已经被移除的石子的价值总和不是 33 的倍数，因此我们可以把石子分成三类，它们的价值除以 33 的余数分别为 0, 1, 20,1,2。我们可以直接用 0, 1, 20,1,2 代表它们的价值，对应的石子数量分别为 \textit{cnt}_0, \textit{cnt}_1, \textit{cnt}_2cnt
     * 0
     * ​
     *  ,cnt
     * 1
     * ​
     *  ,cnt
     * 2
     * ​
     *  。
     *
     * 可以发现，移除类型 0 的石子并不会对总和产生影响，因此类型 0 的石子可以看成是「先后手」交换。具体地，例如当前是 Alice 在进行操作，它发现如
     * 果自己选择移除类型 1 或 2 的石子，那么她在最后一定不能获胜。这时它就可以选择移除一个类型 0 的石子，将同样的局面交给 Bob。如果类型 0 的
     * 石子还没有移除完，那么 Bob 同样可以通过移除一个类型 0 的石子将局面重新交给 Alice。这样不断地往复下去，我们可以得到结论：
     *
     * 如果类型 0 的石子的个数为偶数，那么胜负情况等价于没有类型 0 的石子的胜负情况；
     *
     * 如果类型 0 的石子个数为奇数，那么胜负情况等价于只有 1 个类型 0 的石子的胜负情况。注意这里不能单纯地等价于「没有类型 0 的石子的胜负情况」的
     * 相反情况，这是因为如果所有的石子都被移除完，无论谁移除了最后一个石子，都算 Alice 输。因此如果 Alice 发现自己选择移除类型 1 或 2 的石子不
     * 能获胜，于是选择移除类型 0 的石子，并且它不能获胜的原因是「石子会移除完」，那么 Alice 仍然会输。
     *
     * 将类型 0 的石子考虑完全之后，我们就还剩下类型 1 和 2 的石子了。可以发现，为了保证移除石子的和不为 3 的倍数，操作顺序只有可能为下面的两种情况：
     *
     * 如果 Alice 首先移除类型 1 的石子，那么 Bob 只能移除类型 1 的石子，在这之后 Alice 只能移除类型 2 的石子，Bob 同样只能移除类型 1 的石子。
     * 以此类推，移除石子的类型序列为：
     *
     * 1121212121⋯
     *
     * 如果 Alice 首先移除类型 2 的石子，我们可以类似得到移除石子的类型序列为：
     *
     * 2212121212⋯
     *
     * 作为先手的 Alice 可以在二者中选择一个序列。例如 Alice 选择第一种，那么 Bob 永远移除类型 1 的石子，Alice 除了第一步移除类型 1 的石子
     * 之外，后续永远移除类型 2 的石子。因此 Alice 可以获胜当且仅当：
     *
     * 类型 1 的石子恰好有 1 个，并且类型 2 的石子至少有 1 个。此时 Alice 在 Bob 完成第一步时获胜；
     *
     * 类型 1 的石子至少有 2 个，并且不能比类型 2 的石子多：
     *
     * 如果多 1 个，那么在 Alice 移除最后一个类型 2 的石子后，所有的石子都被移除，Bob 获胜；
     *
     * 如果多 2 个，那么在 Bob 移除最后一个类型 1 的石子后，所有的石子都被移除，Bob 获胜；
     *
     * 如果多超过 2 个，那么 Alice 会在某一步没有类型 2 的石子可以移除，Bob 获胜；
     *
     * 如果一样多或类型 2 的石子更多，那么 Bob 会在某一步没有类型 1 的石子可以移除，Alice 获胜。
     *
     * 上面的两个条件可以归纳为同一个条件，即有类型 1 的石子，并且不能比类型 2 的石子多。
     *
     * 同理，如果 Alice 选择第二种，那么她获胜当且仅当有类型 2 的石子，并且不能比类型 1 的石子多。
     *
     * 上述的两种情况也可以归纳为同一种情况，即类型 1 和类型 2 的石子至少都有 1 个。
     *
     * 细节
     *
     * 回到前面关于类型 0 石子的讨论，可以得到 Alice 获胜的条件：
     *
     * 如果类型 0 的石子的个数为偶数，那么 Alice 获胜当且仅当类型 1 和类型 2 的石子至少都有 1 个；
     *
     * 如果类型 0 的石子的个数为奇数，那么 Alice 获胜当且仅当「在没有类型 0 石子的情况下，Bob 获胜且原因不是因为所有石子都被移除」。
     * 对应到上面的分析即为「类型 1 的石子比类型 2 多超过 2 个」或者「类型 2 的石子比类型 1 多超过 2 个」
     */

    /**
     * 分情况讨论博弈
     * 为了方便，我们用 A 来代指 Alice，用 B 带代指 Bob。
     * <p>
     * A 只有一种获胜方式，是使得 B 在选石子时凑成 3 的倍数；而 B 除了能够通过让 A 凑成 3 的倍数以外，还能通过让游戏常规结束来获胜。
     * <p>
     * 因此整个游戏过程，我们只需要关心「已被移除的石子总和」和「剩余石子个数/价值情况」即可。
     * <p>
     * 更进一步的，我们只需关心已被移除的石子总和是否为 3 的倍数，以及剩余石子的价值与已移除石子总和相加是否凑成 3 的倍数即可。
     * <p>
     * 所以我们可以按照石子价值除以 3 的余数分成三类，并统计相应数量。
     * <p>
     * 不失一般性考虑，某个回合开始前，已移除的石子总和状态为 xx（共三种，分别为除以 3 余数为 0、1 和 2，其中当状态为 0，且非首个回合时，说
     * 明凑成 3 的倍数，游戏结束），剩余石子价值除以 3 的余数 s 分别为 0、1 和 2。
     * <p>
     * 首先如果当前 x=1 时，不能选择 s=2 的石子，否则会导致凑成总和为 3 的倍数而失败；同理 x=2 时，不能选择 s=1 的石
     * 子；而选择 s=0 的数字，不会改变 x 的状态，可看做换手操作。
     * <p>
     * 同时成对的 s=0 的等价于没有 s=0 的石子（双方只需要轮流选完这些 s=0 的石子，最终会回到先手最开始的局面）；而选择与 x 相
     * 同的 s 会导致 x 改变（即 x=1 时，选择 s=1 的石子，会导致 x=2；而 x=2 时，选 s=2 的石子，会导致 x=1）。
     * <p>
     * 明确规则后，是分情况讨论的过程：
     * <p>
     * s=0 的石子数量为偶数：此时等价于没有 s=0 的石子，我们只需要关心 s=1 和 s=2 即可：
     * <p>
     * s=1 的石子数量为 0： 这意味着 A 开始选择的只能是 s=2，此时交给 B 的局面为「x=2、剩余石子只有 s=2」，此时 B
     * 只能选 s=2 的石子，由于 x=2 且选择的石子 s=2，因此交由回 A 的局面为「x=1，剩余是在只有 s=2」，因此游戏继
     * 续的话 A 必败，同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 A 仍为必败；
     * <p>
     * s=2 的石子数量为 0：分析同理，A 只能选 s=1，此时交给 B 的局面为「x=1、剩余石子只有 s=1」，此时 B 只能选 s=1
     * 的石子，由于 x=1 且选择的石子 s=1，因此交由回 A 的局面为「x=2，剩余是在只有 s=1」，因此游戏继续的话 A 必败，同
     * 时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 A 仍为必败；
     * <p>
     * s=1 和 s=2 的石子数量均不为 0：A 选数量不是最多的一类石子，B 下一回合只能选择相同类型的石子（或是无从选择导致失败），然后游
     * 戏继续，最终 B 会先进入「只能凑成 3 的倍数」的局面导致失败，即 A 必胜。
     * <p>
     * s=0 的石子数量为奇数：此时等价于有一次换手机会，该换手机会必然应用在「对必败局面进行转移」才有意义，因此只有 s=1 和 s=2 的石子
     * 数量差大于 2，A 的先手优势不会因为存在换手机会而被转移：
     * <p>
     * 两者数量差不超过 2：此时 B 可以利用「对方凑成 3 的倍数必败」规则和「优先使用 s=0 石子」权利来进入确保自己为必胜态：
     * <p>
     * 举个 🌰，当 s=1 和 s=2 的石子数量相等，虽然有 s=0 的石子，A 先手，但是 A 的首个回合必然不能选 s=0，否则马上失败
     * 结束，因此 A 只能选 s=1 或 s=2，此时 B直接选择 s=0 的石子，交由给 A 的局面 x 没有发生改变，A 只能选择与首个回合相同
     * 的 s 游戏才能继续，因此局面会变为「B 先手、s=1 和 s=2 的石子数量差为 2」，游戏继续，最终 A 会先遇到「只能凑成 3 的倍数」
     * 的局面，即 B 必胜。
     * <p>
     * 两者数量不等，但数量差不超过 2：此时无论 A 选择数量较少或较多的 s，B 都在第二回合马上使用 s=0 的石子进行换手，A 只能继续选与第一回
     * 合相同类型的的石子，游戏才能进行，最终 A 会先遇到「只能凑成 3 的倍数」或「石子被取完」的局面，即 B 必胜。
     * <p>
     * 两者数量差超过 2 ：此时即使 A 只要确保第一次选择数量较多的 s，不管 B 是否使用「优先使用 s=0」的石子，A 都有足够次数数量多 s 来
     * 抵消换手（或是在 B 放弃使用 s=0 之后马上使用），最终都是 B 最先遇到「只能凑成 3 的倍数」的局面，即 A 获胜。
     */
    public static boolean stoneGameIX(int[] stones) {
        int cnt0 = 0, cnt1 = 0, cnt2 = 0; // cnt0等价于换先后手的机会
        for (int stone : stones) {
            int type = stone % 3;
            if (type == 0) ++cnt0;
            else if (type == 1) ++cnt1;
            else ++cnt2;
        }
        if (cnt0 % 2 == 0) return cnt1 >= 1 && cnt2 >= 1;
        // 余数0的石子数量为奇数：此时等价于有一次换手机会，该换手机会必然应用在「对必败局面进行转移」才有意义，因此只有 s=1 和 s=2 的石子数量差
        // 大于 2，A 的先手优势不会因为存在换手机会而被转移：
        return cnt1 - cnt2 > 2 || cnt2 - cnt1 > 2;
    }

    public static boolean stoneGameIXO(int[] stones) {
        int[] cnt = new int[3];
        for (int stone : stones) {
            cnt[stone % 3]++;
        }
        if ((cnt[0] & 1) == 0) return cnt[1] > 0 && cnt[2] > 0;
        return Math.abs(cnt[1] - cnt[2]) > 2;
    }

}
