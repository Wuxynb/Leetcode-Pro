package ojs.codeforce;

import java.util.Scanner;

/**
 * D. 老鼠袋
 * <p>
 * 龙和公主决定在除夕夜做什么：龙建议飞到山上欣赏月光下仙女的舞蹈，而公主则建议早点睡觉。他们对友好地达成协议感到绝望，并决定屈服于机会。
 * <p>
 * <p>
 * 他们轮流从一个最初包含w个白老鼠和b个黑老鼠的袋子中抽出老鼠，最先抽出白色老鼠的人获胜。每一只老鼠被龙拉出来后，剩下的都惊慌失措，其中一只自己从袋子
 * 里跳了出来（公主小心翼翼地把老鼠从袋子里拉出来，没有吓到它们）。公主先拉。她获胜的概率是多少？
 * <p>
 * 如果袋子里的老鼠都结束了，没有人把白色的老鼠拉出来，龙就被认为是赢家。自己跳出来的老鼠不被认为是被拉出来的（它们不决定获胜者）。一旦离开袋子，老鼠
 * 就不会回到袋子里。任何一只老鼠以相同的概率被拉出袋子，任何一只老鼠以相同的概率跳出袋子。
 * <p>
 * <p>
 * 输入数据
 * <p>
 * 输入的唯一行包含两个整数w和b ( 0 ≤ w , b ≤ 1000 )。
 * <p>
 * <p>
 * 输出
 * <p>
 * 打印公主获胜的概率。如果绝对或相对误差不超过 10^-9，则认为答案正确。
 * <p>
 * <p>
 * 例子
 * <p>
 * 输入
 * <p>
 * 1 3
 * <p>
 * 输出
 * <p>
 * 0.500000000
 * <p>
 * 输入
 * <p>
 * 5 5
 * <p>
 * 输出
 * <p>
 * 0.658730159
 * <p>
 * 笔记
 * <p>
 * 让我们仔细看看第一个测试。以 1/4 的概率，公主会立即画出一只白鼠并获胜。之后以 3/4 * 2/3 = 1/2 的概率，龙会抽到一只黑老鼠而不是获胜；然后一只
 * 白色和一只黑色的老鼠会留在袋子里，其中一只会跳出来，第二只会在第二回合交给公主。如果剩下的老鼠是白色的，公主获胜（概率1/2 * 1/2 = 1/4），否则
 * 老鼠用完，按照规则龙获胜。
 */
public class P148D {
    static int maxn = 1005;
    static double[][] dp = new double[maxn][maxn]; // dp[i][j] 表示轮到公主时袋子里有i只白鼠，j只黑鼠公主赢的概率

    /**
     * 设 f(i,j)为轮到公主时袋子里有i只白鼠，j只黑鼠，公主赢的概率。初始化边界，f(0,j)=0因为没有白鼠了算龙赢，f(i,0)=1因为抓一只就是白鼠，公主赢。
     * 考虑 fi,j 的转移：
     * <p>
     * 1. 公主抓到一只白鼠，公主赢了。概率为 i/(i+j) ；
     * <p>
     * 2. 公主抓到一只黑鼠，龙抓到一只白鼠，龙赢了。概率为 (j/(i+j))⋅(i/(i+j−1)) ；
     * <p>
     * 3. 公主抓到一只黑鼠，龙抓到一只黑鼠，跑出来一只黑鼠，转移到 f(i,j−3) 。概率为 j/(i+j)⋅(j−1/i+j−1)⋅(j−2/i+j−2) ；
     * <p>
     * 4. 公主抓到一只黑鼠，龙抓到一只黑鼠，跑出来一只白鼠，转移到 f(i−1,j−2) 。概率为 j/(i+j)⋅(j−1/i+j−1)⋅(i/i+j−2) ；
     * <p>
     * <p>
     * 考虑公主赢的概率，第二种情况不参与计算。并且要保证后两种情况合法，所以还要判断 i,j 的大小，满足第三种情况至少要有 3 只黑鼠，满足第四种情况要有 1 只白鼠和 2 只黑鼠。
     */
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int w = scan.nextInt(), b = scan.nextInt();
        // 初始化
        for (int i = 1; i <= w; i++) dp[i][0] = 1;
        for (int j = 1; j <= b; j++) dp[0][j] = 0;
        for (int i = 1; i <= w; i++) {
            for (int j = 1; j <= b; j++) {
                dp[i][j] += (double) i / (i + j); // 拿到白鼠的概率
                if (j >= 3)
                    dp[i][j] += (double) j / (i + j) * (j - 1) / (i + j - 1) * (j - 2) / (i + j - 2) * dp[i][j - 3];
                if (i >= 1 && j >= 2)
                    dp[i][j] += (double) j / (i + j) * (j - 1) / (i + j - 1) * i / (i + j - 2) * dp[i - 1][j - 2];
            }
        }
        System.out.printf("%.9f", dp[w][b]);
    }
}
