package ojs.poj;

import java.util.Scanner;

/**
 * 正在收集Bug
 * <p>
 * 描述
 * <p>
 * 伊凡喜欢收藏。与其他收集邮票、硬币或其他材料的人不同，他收集软件漏洞。当Ivan得到一个新程序时，他将所有可能的bug分为n类。每天，他都会发现程序中只
 * 有一个bug，并将有关它及其类别的信息添加到电子表格中。当他在所有bug类别中发现bug时，他称该程序令人恶心，将此电子表格发布在主页上，完全忘记了该程序。
 * Macrosoft和Microhard两家公司竞争激烈。Microhard希望减少Macrosoft程序的销售额。他们雇佣伊凡来证明这个节目很恶心。然而，Ivan有一个复杂的问
 * 题。这个新程序有s个子组件，在每个子组件中查找所有类型的错误需要很长时间才能达到目标。因此，Ivan和Microhard同意使用一个更简单的标准——Ivan应该
 * 在每个子系统中找到至少一个bug，并在每个类别中找到至少一个bug。
 * <p>
 * Macrosoft知道这些计划，并希望估计Ivan称其程序令人厌恶所需的时间。这一点很重要，因为该公司很快就会发布一个新版本，因此它可以纠正计划并更快地发
 * 布。没有人会对伊凡关于过时版本可靠性的观点感兴趣。
 * 在程序中发现的bug可以属于任何类别，概率相等。类似地，可以在任何给定的子系统中以相同的概率发现该错误。任何特定的bug都不能属于两个不同的类别，也不
 * 能同时发生在两个不同的子系统中。程序中的错误数量几乎是无限的，因此在某个子系统中发现某一类别的新错误的概率在该子系统中发现该类别的任何错误后都不会
 * 降低。
 * <p>
 * 找出一个平均所需时间（以Ivan工作的天数为单位）来命名该程序令人恶心。
 * <p>
 * 输入
 * <p>
 * 输入文件包含两个整数，n和s（0< n，s<= 1000）。
 * <p>
 * 输出
 * <p>
 * 输出Ivan调用程序所需的预期工作日，精确到小数点后4位。
 * <p>
 * 样本输入
 * <p>
 * 1 2
 * <p>
 * 样本输出
 * <p>
 * 3
 * <p>
 * 来源
 */
public class P2096 {
    static int maxn = 1005;
    static double[][] dp = new double[maxn][maxn]; // dp[i][j] 表示已经找到i种bug分类， j个子系统的bug，达到目标状态的期望天数。

    /**
     * 令 f(i,j)为已经找到i种bug分类， j个子系统的bug，达到目标状态的期望天数。这里的目标状态是找到n种bug分类， j个子系统的bug。那么就有
     * f(n,s)=0 ，因为已经达到了目标状态，不需要用更多的天数去发现 bug了，于是就以目标状态为起点开始递推，答案是 f(0,0)。
     * <p>
     * 考虑 f(i,j)的状态转移：
     * <p>
     * f(i,j)，发现一个 bug 属于已经发现的 i 种 bug 分类， j 个子系统，概率为 p1=i/n⋅j/s
     * <p>
     * f(i,j+1)，发现一个 bug 属于已经发现的 i 种 bug 分类，不属于已经发现的子系统，概率为 p2=i/n⋅(1−j/s)
     * <p>
     * f(i+1,j)，发现一个 bug 不属于已经发现 bug 分类，属于 j 个子系统，概率为 p3=(1−i/n)⋅j/s
     * <p>
     * f(i+1,j+1)，发现一个 bug 不属于已经发现 bug 分类，不属于已经发现的子系统，概率为 p4=(1−i/n)⋅(1−j/s)
     * <p>
     * 再根据期望的线性性质，就可以得到状态转移方程：
     * <p>
     * f(i,j)=p1⋅f(i,j)+p2⋅f(i,j+1)+p3⋅f(i+1,j)+p4⋅f(i+1,j+1)+1
     * =(p2⋅f(i,j+1)+p3⋅f(i+1,j)+p4⋅f(i+1,j+1)+1)/(1−p1)
     */
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), s = scan.nextInt();
        for (int i = n; i >= 0; i--) {
            for (int j = s; j >= 0; j--) {
                if (i == n && j == s) continue; // 跳过初始值
                double p1, p2, p3, p4;
                p1 = (double) i * j / (n * s); // dp[i][j];
                p2 = (double) (n - i) * j / (n * s); // dp[i+1][j];
                p3 = (double) i * (s - j) / (n * s); // dp[i][j+1];
                p4 = (double) (n - i) * (s - j) / (n * s);
                dp[i][j] = (1 + p2 * dp[i + 1][j] + p3 * dp[i][j + 1] +
                        p4 * dp[i + 1][j + 1]) / (1 - p1);
            }
        }
        System.out.printf("%.4f", dp[0][0]);
    }
}
